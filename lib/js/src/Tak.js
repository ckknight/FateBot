// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_list = require("bs-platform/lib/js/js_list.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_MapInt = require("bs-platform/lib/js/belt_MapInt.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Belt_MutableSetInt = require("bs-platform/lib/js/belt_MutableSetInt.js");

function position(x, y) {
  return /* tuple */[
          x,
          y
        ];
}

function positionToIndex(boardSize, param) {
  return Caml_int32.imul(param[1], boardSize) + param[0] | 0;
}

function getStonesByPosition(position, board) {
  return Belt_MapInt.getWithDefault(board[/* pieces */6], positionToIndex(board[/* boardSize */0], position), /* [] */0);
}

function getTopStoneByPosition(position, board) {
  var match = getStonesByPosition(position, board);
  if (match) {
    return /* Some */[match[0]];
  } else {
    return /* None */0;
  }
}

function addStoneToPosition(stone, position, board) {
  return Belt_MapInt.updateU(board[/* pieces */6], positionToIndex(board[/* boardSize */0], position), (function (stones) {
                var stones$1 = Belt_Option.getWithDefault(stones, /* [] */0);
                return /* Some */[/* :: */[
                          stone,
                          stones$1
                        ]];
              }));
}

function piecesRemainingByBoardSize(boardSize) {
  var switcher = boardSize - 3 | 0;
  if (switcher > 5 || switcher < 0) {
    return /* None */0;
  } else {
    switch (switcher) {
      case 0 : 
          return /* Some */[/* tuple */[
                    10,
                    0
                  ]];
      case 1 : 
          return /* Some */[/* tuple */[
                    15,
                    0
                  ]];
      case 2 : 
          return /* Some */[/* tuple */[
                    21,
                    1
                  ]];
      case 3 : 
          return /* Some */[/* tuple */[
                    30,
                    1
                  ]];
      case 4 : 
          return /* Some */[/* tuple */[
                    40,
                    2
                  ]];
      case 5 : 
          return /* Some */[/* tuple */[
                    50,
                    2
                  ]];
      
    }
  }
}

function create(boardSize) {
  var match = piecesRemainingByBoardSize(boardSize);
  if (match) {
    var match$1 = match[0];
    var capstonesRemaining = match$1[1];
    var piecesRemaining = match$1[0];
    return /* record */[
            /* boardSize */boardSize,
            /* whitePiecesRemaining */piecesRemaining,
            /* blackPiecesRemaining */piecesRemaining,
            /* whiteCapstonesRemaining */capstonesRemaining,
            /* blackCapstonesRemaining */capstonesRemaining,
            /* status : WhiteInitial */0,
            /* pieces */Belt_MapInt.empty,
            /* actions : [] */0
          ];
  } else {
    return Pervasives.failwith("Unacceptable boardSize " + String(boardSize));
  }
}

function boardSize(board) {
  return board[/* boardSize */0];
}

function canPlace(board) {
  var match = board[/* status */5];
  if (match >= 4) {
    return false;
  } else {
    return true;
  }
}

function whoseTurn(board) {
  var match = board[/* status */5];
  switch (match) {
    case 0 : 
    case 2 : 
        return /* Some */[/* White */0];
    case 1 : 
    case 3 : 
        return /* Some */[/* Black */1];
    case 4 : 
    case 5 : 
        return /* None */0;
    
  }
}

function isPositionTaken(position, board) {
  return !Js_list.isEmpty(getStonesByPosition(position, board));
}

function isPositionWithinBounds(param, param$1) {
  var boardSize = param$1[/* boardSize */0];
  var y = param[1];
  var x = param[0];
  if (x >= 0 && x < boardSize && y >= 0) {
    return y < boardSize;
  } else {
    return false;
  }
}

function applyDirection(param, direction) {
  var y = param[1];
  var x = param[0];
  switch (direction) {
    case 0 : 
        return /* tuple */[
                x,
                y - 1 | 0
              ];
    case 1 : 
        return /* tuple */[
                x + 1 | 0,
                y
              ];
    case 2 : 
        return /* tuple */[
                x,
                y + 1 | 0
              ];
    case 3 : 
        return /* tuple */[
                x - 1 | 0,
                y
              ];
    
  }
}

function isRoad(stoneType) {
  if (stoneType !== 1) {
    return true;
  } else {
    return false;
  }
}

function hasRoad(color, initialPosition, isEnd, board) {
  var connections = Belt_MutableSetInt.make(/* () */0);
  var aux = function (position) {
    if (isPositionWithinBounds(position, board)) {
      var match = getTopStoneByPosition(position, board);
      if (match) {
        var match$1 = match[0];
        if (match$1[0] === color && isRoad(match$1[1])) {
          var added = Belt_MutableSetInt.addCheck(connections, positionToIndex(board[/* boardSize */0], position));
          if (added) {
            if (Curry._1(isEnd, position)) {
              return true;
            } else {
              return Belt_List.someU(/* :: */[
                          /* North */0,
                          /* :: */[
                            /* East */1,
                            /* :: */[
                              /* South */2,
                              /* :: */[
                                /* West */3,
                                /* [] */0
                              ]
                            ]
                          ]
                        ], (function (direction) {
                            return aux(applyDirection(position, direction));
                          }));
            }
          } else {
            return false;
          }
        } else {
          return false;
        }
      } else {
        return false;
      }
    } else {
      return false;
    }
  };
  return aux(initialPosition);
}

function hasHorizontalRoad(color, row, board) {
  return hasRoad(color, /* tuple */[
              0,
              row
            ], (function (param) {
                return param[0] >= (board[/* boardSize */0] - 1 | 0);
              }), board);
}

function calculateRoads(color, board) {
  var __x = Belt_List.makeByU(board[/* boardSize */0], (function (index) {
          return index;
        }));
  return Belt_List.someU(__x, (function (index) {
                if (hasHorizontalRoad(color, index, board)) {
                  return true;
                } else {
                  var color$1 = color;
                  var column = index;
                  var board$1 = board;
                  return hasRoad(color$1, /* tuple */[
                              column,
                              0
                            ], (function (param) {
                                return param[1] >= (board$1[/* boardSize */0] - 1 | 0);
                              }), board$1);
                }
              }));
}

function checkForWinner(turnColor, board) {
  var roads = Belt_List.keepMapU(/* :: */[
        /* White */0,
        /* :: */[
          /* Black */1,
          /* [] */0
        ]
      ], (function (color) {
          var match = calculateRoads(color, board);
          if (match) {
            return /* Some */[color];
          } else {
            return /* None */0;
          }
        }));
  var roadWinner;
  if (roads) {
    var match = roads[1];
    roadWinner = match ? (
        match[1] ? /* None */0 : /* Some */[turnColor]
      ) : /* Some */[roads[0]];
  } else {
    roadWinner = /* None */0;
  }
  if (roadWinner) {
    var match$1 = roadWinner[0] === /* Black */1;
    return /* record */[
            /* boardSize */board[/* boardSize */0],
            /* whitePiecesRemaining */board[/* whitePiecesRemaining */1],
            /* blackPiecesRemaining */board[/* blackPiecesRemaining */2],
            /* whiteCapstonesRemaining */board[/* whiteCapstonesRemaining */3],
            /* blackCapstonesRemaining */board[/* blackCapstonesRemaining */4],
            /* status */match$1 ? /* BlackWin */5 : /* WhiteWin */4,
            /* pieces */board[/* pieces */6],
            /* actions */board[/* actions */7]
          ];
  } else {
    return board;
  }
}

function doPlace(stoneType, position, board) {
  if (!canPlace(board) || !isPositionWithinBounds(position, board) || isPositionTaken(position, board)) {
    return /* None */0;
  } else {
    var match = board[/* status */5];
    var match$1;
    switch (match) {
      case 0 : 
          match$1 = /* tuple */[
            /* Black */1,
            true
          ];
          break;
      case 1 : 
          match$1 = /* tuple */[
            /* White */0,
            true
          ];
          break;
      case 2 : 
          match$1 = /* tuple */[
            /* White */0,
            false
          ];
          break;
      case 3 : 
          match$1 = /* tuple */[
            /* Black */1,
            false
          ];
          break;
      case 4 : 
      case 5 : 
          match$1 = Pervasives.failwith("Unexpected board.status");
          break;
      
    }
    if (match$1[1] && stoneType !== /* FlatStone */0) {
      return /* None */0;
    } else {
      var blackCapstonesRemaining = board[/* blackCapstonesRemaining */4];
      var whiteCapstonesRemaining = board[/* whiteCapstonesRemaining */3];
      var blackPiecesRemaining = board[/* blackPiecesRemaining */2];
      var whitePiecesRemaining = board[/* whitePiecesRemaining */1];
      var stoneColor = match$1[0];
      var match$2 = stoneColor ? (
          stoneType >= 2 ? /* tuple */[
              whiteCapstonesRemaining,
              blackCapstonesRemaining - 1 | 0,
              whitePiecesRemaining,
              blackPiecesRemaining
            ] : /* tuple */[
              whiteCapstonesRemaining,
              blackCapstonesRemaining,
              whitePiecesRemaining,
              blackPiecesRemaining - 1 | 0
            ]
        ) : (
          stoneType >= 2 ? /* tuple */[
              whiteCapstonesRemaining - 1 | 0,
              blackCapstonesRemaining,
              whitePiecesRemaining,
              blackPiecesRemaining
            ] : /* tuple */[
              whiteCapstonesRemaining,
              blackCapstonesRemaining,
              whitePiecesRemaining - 1 | 0,
              blackPiecesRemaining
            ]
        );
      var match$3 = board[/* status */5];
      var tmp;
      switch (match$3) {
        case 0 : 
            tmp = /* BlackInitial */1;
            break;
        case 2 : 
            tmp = /* BlackTurn */3;
            break;
        case 1 : 
        case 3 : 
            tmp = /* WhiteTurn */2;
            break;
        case 4 : 
        case 5 : 
            tmp = Pervasives.failwith("Unexpected board.status");
            break;
        
      }
      return /* Some */[checkForWinner(Belt_Option.getExn(whoseTurn(board)), /* record */[
                    /* boardSize */board[/* boardSize */0],
                    /* whitePiecesRemaining */match$2[2],
                    /* blackPiecesRemaining */match$2[3],
                    /* whiteCapstonesRemaining */match$2[0],
                    /* blackCapstonesRemaining */match$2[1],
                    /* status */tmp,
                    /* pieces */addStoneToPosition(/* tuple */[
                          stoneColor,
                          stoneType
                        ], position, board),
                    /* actions */board[/* actions */7]
                  ])];
    }
  }
}

function canMove(board) {
  var match = board[/* status */5];
  if (match === 3 || match === 2) {
    return true;
  } else {
    return false;
  }
}

function leftStones(input) {
  var leftStonesAux = function (_input, _isFirst) {
    while(true) {
      var isFirst = _isFirst;
      var input = _input;
      if (input) {
        var value = input[0];
        if (value < 1 && !(value === 0 && isFirst)) {
          return Pervasives.failwith("Expected at least 1, or 0 on the first");
        } else {
          _isFirst = false;
          _input = input[1];
          continue ;
        }
      } else if (isFirst) {
        return Pervasives.failwith("Expected at least one item in list");
      } else {
        return /* () */0;
      }
    };
  };
  leftStonesAux(input, true);
  return input;
}

function movePieces(stones, position, direction, leftStones, board) {
  var aux = function (stonesInHand, position, leftStones, board) {
    if (leftStones) {
      if (stonesInHand) {
        var restLeftStones = leftStones[1];
        if (isPositionWithinBounds(position, board)) {
          var match = getTopStoneByPosition(position, board);
          var stopped;
          if (match) {
            switch (match[0][1]) {
              case 0 : 
                  stopped = false;
                  break;
              case 1 : 
                  stopped = !Js_list.isEmpty(stonesInHand[1]) || stonesInHand[0][1] !== /* Capstone */2;
                  break;
              case 2 : 
                  stopped = true;
                  break;
              
            }
          } else {
            stopped = false;
          }
          if (stopped) {
            return /* None */0;
          } else {
            var __x = Belt_List.splitAt(stonesInHand, leftStones[0]);
            return Belt_Option.flatMapU(__x, (function (param) {
                          var stonesToLeave = param[0];
                          return aux(param[1], applyDirection(position, direction), restLeftStones, /* record */[
                                      /* boardSize */board[/* boardSize */0],
                                      /* whitePiecesRemaining */board[/* whitePiecesRemaining */1],
                                      /* blackPiecesRemaining */board[/* blackPiecesRemaining */2],
                                      /* whiteCapstonesRemaining */board[/* whiteCapstonesRemaining */3],
                                      /* blackCapstonesRemaining */board[/* blackCapstonesRemaining */4],
                                      /* status */board[/* status */5],
                                      /* pieces */Belt_MapInt.updateU(board[/* pieces */6], positionToIndex(board[/* boardSize */0], position), (function (currentStones) {
                                              return /* Some */[Belt_List.reverseConcat(stonesToLeave, Belt_List.mapU(Belt_Option.getWithDefault(currentStones, /* [] */0), (function (stone) {
                                                                  if (stone[1] !== 1) {
                                                                    return stone;
                                                                  } else {
                                                                    return /* tuple */[
                                                                            stone[0],
                                                                            /* FlatStone */0
                                                                          ];
                                                                  }
                                                                })))];
                                            })),
                                      /* actions */board[/* actions */7]
                                    ]);
                        }));
          }
        } else {
          return /* None */0;
        }
      } else {
        return /* None */0;
      }
    } else if (stonesInHand) {
      return /* None */0;
    } else {
      return /* Some */[board[/* pieces */6]];
    }
  };
  return aux(Belt_List.reverse(stones), position, leftStones, /* record */[
              /* boardSize */board[/* boardSize */0],
              /* whitePiecesRemaining */board[/* whitePiecesRemaining */1],
              /* blackPiecesRemaining */board[/* blackPiecesRemaining */2],
              /* whiteCapstonesRemaining */board[/* whiteCapstonesRemaining */3],
              /* blackCapstonesRemaining */board[/* blackCapstonesRemaining */4],
              /* status */board[/* status */5],
              /* pieces */Belt_MapInt.remove(board[/* pieces */6], positionToIndex(board[/* boardSize */0], position)),
              /* actions */board[/* actions */7]
            ]);
}

function doMove(position, direction, leftStones, board) {
  if (canMove(board)) {
    var stones = getStonesByPosition(position, board);
    var match = whoseTurn(board);
    if (stones && match) {
      var playerColor = match[0];
      if (stones[0][0] === playerColor) {
        var match$1 = movePieces(stones, position, direction, leftStones, board);
        if (match$1) {
          var match$2 = board[/* status */5];
          return /* Some */[checkForWinner(playerColor, /* record */[
                        /* boardSize */board[/* boardSize */0],
                        /* whitePiecesRemaining */board[/* whitePiecesRemaining */1],
                        /* blackPiecesRemaining */board[/* blackPiecesRemaining */2],
                        /* whiteCapstonesRemaining */board[/* whiteCapstonesRemaining */3],
                        /* blackCapstonesRemaining */board[/* blackCapstonesRemaining */4],
                        /* status */match$2 !== 2 ? (
                            match$2 !== 3 ? Pervasives.failwith("Unexpected board.status") : /* WhiteTurn */2
                          ) : /* BlackTurn */3,
                        /* pieces */match$1[0],
                        /* actions */board[/* actions */7]
                      ])];
        } else {
          return /* None */0;
        }
      } else {
        return /* None */0;
      }
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

function dispatch(action, board) {
  var __x;
  __x = action.tag ? doMove(action[0], action[1], action[2], board) : doPlace(action[0], action[1], board);
  return Belt_Option.mapU(__x, (function (board) {
                return /* record */[
                        /* boardSize */board[/* boardSize */0],
                        /* whitePiecesRemaining */board[/* whitePiecesRemaining */1],
                        /* blackPiecesRemaining */board[/* blackPiecesRemaining */2],
                        /* whiteCapstonesRemaining */board[/* whiteCapstonesRemaining */3],
                        /* blackCapstonesRemaining */board[/* blackCapstonesRemaining */4],
                        /* status */board[/* status */5],
                        /* pieces */board[/* pieces */6],
                        /* actions : :: */[
                          action,
                          board[/* actions */7]
                        ]
                      ];
              }));
}

function actions(board) {
  return board[/* actions */7];
}

function place(stoneType, position, board) {
  return dispatch(/* Place */Block.__(0, [
                stoneType,
                position
              ]), board);
}

function move(position, direction, leftStones, board) {
  return dispatch(/* Move */Block.__(1, [
                position,
                direction,
                leftStones
              ]), board);
}

var pieces = getStonesByPosition;

exports.create = create;
exports.boardSize = boardSize;
exports.position = position;
exports.place = place;
exports.leftStones = leftStones;
exports.move = move;
exports.pieces = pieces;
exports.whoseTurn = whoseTurn;
exports.dispatch = dispatch;
exports.actions = actions;
/* No side effect */
