// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");

function some(value) {
  return /* Some */[value];
}

function isSome(option) {
  if (option) {
    return true;
  } else {
    return false;
  }
}

function isNone(option) {
  if (option) {
    return false;
  } else {
    return true;
  }
}

function bind(f, option) {
  if (option) {
    return Curry._1(f, option[0]);
  } else {
    return /* None */0;
  }
}

function equal(eq, a, b) {
  if (a) {
    if (b) {
      return Curry._2(eq, a[0], b[0]);
    } else {
      return false;
    }
  } else {
    return isNone(b);
  }
}

function map(f) {
  return (function (param) {
      return bind((function (x) {
                    return /* Some */[Curry._1(f, x)];
                  }), param);
    });
}

function mapTo(x) {
  return (function (param) {
      return bind((function () {
                    return /* Some */[x];
                  }), param);
    });
}

function iter(f, option) {
  if (option) {
    return Curry._1(f, option[0]);
  } else {
    return /* () */0;
  }
}

function value($$default, option) {
  if (option) {
    return option[0];
  } else {
    return $$default;
  }
}

function valueMap($$default, f, option) {
  if (option) {
    return Curry._1(f, option[0]);
  } else {
    return $$default;
  }
}

function filter(f) {
  return (function (param) {
      return bind((function (x) {
                    if (Curry._1(f, x)) {
                      return /* Some */[x];
                    } else {
                      return /* None */0;
                    }
                  }), param);
    });
}

function both(x, y) {
  return bind((function (a) {
                var f = function (b) {
                  return /* tuple */[
                          a,
                          b
                        ];
                };
                return (function (param) {
                            return bind((function (x) {
                                          return /* Some */[Curry._1(f, x)];
                                        }), param);
                          })(y);
              }), x);
}

function map2(f, x, y) {
  var f$1 = function (param) {
    return Curry._2(f, param[0], param[1]);
  };
  return (function (param) {
              return bind((function (x) {
                            return /* Some */[Curry._1(f$1, x)];
                          }), param);
            })(both(x, y));
}

function orElse(f, g, x) {
  var t = Curry._1(f, x);
  if (t) {
    return t;
  } else {
    return Curry._1(g, x);
  }
}

function orRaise(exn, option) {
  if (option) {
    return option[0];
  } else {
    throw exn;
  }
}

function firstSome(x, y) {
  if (x) {
    return x;
  } else {
    return y;
  }
}

function someIf(condition, x) {
  if (condition) {
    return /* Some */[x];
  } else {
    return /* None */0;
  }
}

function orDefault(f, option) {
  if (option) {
    return option[0];
  } else {
    return Curry._1(f, /* () */0);
  }
}

function $great$great$eq(option, f) {
  return bind(f, option);
}

function $pipe$pipe$great(option, f) {
  return bind((function (x) {
                return /* Some */[Curry._1(f, x)];
              }), option);
}

var Infix = /* module */[
  /* >>= */$great$great$eq,
  /* ||> */$pipe$pipe$great
];

var Option = /* module */[
  /* some */some,
  /* isSome */isSome,
  /* isNone */isNone,
  /* bind */bind,
  /* equal */equal,
  /* map */map,
  /* mapTo */mapTo,
  /* iter */iter,
  /* value */value,
  /* valueMap */valueMap,
  /* filter */filter,
  /* both */both,
  /* map2 */map2,
  /* orElse */orElse,
  /* orRaise */orRaise,
  /* firstSome */firstSome,
  /* someIf */someIf,
  /* orDefault */orDefault,
  /* Infix */Infix
];

function $$parseInt(defaultValue, str) {
  var value = Number(str);
  if (isNaN(value)) {
    return defaultValue;
  } else {
    return value | 0;
  }
}

function arrayRange(count) {
  var array = /* array */[];
  for(var x = 0 ,x_finish = count - 1 | 0; x <= x_finish; ++x){
    array.push(x);
  }
  return array;
}

function arrayZip(x, y) {
  return x.map((function (value, index) {
                return /* tuple */[
                        value,
                        Caml_array.caml_array_get(y, index)
                      ];
              }));
}

function promiseMap(f) {
  return (function (param) {
      return param.then((function (x) {
                    return Promise.resolve(Curry._1(f, x));
                  }));
    });
}

function promiseEnd(promise) {
  promise.catch((function (error) {
          console.log(error);
          return Promise.resolve(/* () */0);
        }));
  return /* () */0;
}

function exnCode(exn) {
  return Js_primitive.undefined_to_opt(exn.code);
}

function parseJson(data) {
  try {
    return /* Some */[JSON.parse(data)];
  }
  catch (exn){
    return /* None */0;
  }
}

function memoize(fn) {
  var cache = [/* None */0];
  return (function (arg) {
      var match = cache[/* contents */0];
      if (match) {
        return match[0];
      } else {
        var result = Curry._1(fn, arg);
        cache[0] = /* Some */[result];
        return result;
      }
    });
}

function magicAsArray(item) {
  if (Array.isArray(item)) {
    return item;
  } else {
    return /* array */[item];
  }
}

exports.Option = Option;
exports.$$parseInt = $$parseInt;
exports.arrayRange = arrayRange;
exports.arrayZip = arrayZip;
exports.promiseMap = promiseMap;
exports.promiseEnd = promiseEnd;
exports.exnCode = exnCode;
exports.parseJson = parseJson;
exports.memoize = memoize;
exports.magicAsArray = magicAsArray;
/* No side effect */
