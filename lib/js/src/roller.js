// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Utils = require("./utils.js");
var Random = require("./random.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");

function getMatchLength(match__) {
  return Caml_array.caml_array_get(match__, 0).length;
}

function diceExpMatcher(str) {
  return Utils.Option[/* map */5]((function (match__) {
                  var diceCount = Utils.$$parseInt(1, Caml_array.caml_array_get(match__, 1));
                  var match = Caml_array.caml_array_get(match__, 2).toLowerCase();
                  var dice;
                  switch (match) {
                    case "%" : 
                        dice = /* Dice */Block.__(1, [
                            diceCount,
                            1,
                            100
                          ]);
                        break;
                    case "f" : 
                        dice = /* Dice */Block.__(1, [
                            diceCount,
                            -1,
                            1
                          ]);
                        break;
                    default:
                      dice = Boolean(Caml_array.caml_array_get(match__, 4)) ? /* Dice */Block.__(1, [
                            diceCount,
                            Utils.$$parseInt(1, Caml_array.caml_array_get(match__, 3)),
                            Utils.$$parseInt(1, Caml_array.caml_array_get(match__, 4))
                          ]) : /* Dice */Block.__(1, [
                            diceCount,
                            1,
                            Utils.$$parseInt(6, Caml_array.caml_array_get(match__, 3))
                          ]);
                  }
                  return /* tuple */[
                          /* :: */[
                            dice,
                            /* [] */0
                          ],
                          Caml_array.caml_array_get(match__, 0).length
                        ];
                }))(Js_primitive.null_to_opt(str.match(new RegExp("^([1-9][0-9]*)?(?:d|D)((?:([1-9][0-9]*)(?:\\.\\.([1-9][0-9]*))?)|\\%|f|F)"))));
}

function constantMatcher(str) {
  return Utils.Option[/* map */5]((function (match__) {
                  var value = Utils.$$parseInt(0, Caml_array.caml_array_get(match__, 1));
                  return /* tuple */[
                          /* :: */[
                            /* Constant */Block.__(2, [value]),
                            /* [] */0
                          ],
                          Caml_array.caml_array_get(match__, 0).length
                        ];
                }))(Js_primitive.null_to_opt(str.match(new RegExp("^([1-9][0-9]*)"))));
}

function spaceMatcher(str) {
  return Utils.Option[/* map */5]((function (match__) {
                  return /* tuple */[
                          /* [] */0,
                          Caml_array.caml_array_get(match__, 0).length
                        ];
                }))(Js_primitive.null_to_opt(str.match(new RegExp("^\\s*"))));
}

var orCombinator = Utils.Option[/* orElse */13];

function andCombinator(f, g, str) {
  return Utils.Option[/* bind */3]((function (param) {
                var index = param[1];
                var tokens = param[0];
                return Utils.Option[/* map */5]((function (param) {
                                return /* tuple */[
                                        Pervasives.$at(tokens, param[0]),
                                        index + param[1] | 0
                                      ];
                              }))(Curry._1(g, str.substring(index)));
              }), Curry._1(f, str));
}

function andMaybeCombinator(f, g, str) {
  return Utils.Option[/* map */5]((function (x) {
                  var index = x[1];
                  var match = Curry._1(g, str.substring(index));
                  if (match) {
                    var match$1 = match[0];
                    return /* tuple */[
                            Pervasives.$at(x[0], match$1[0]),
                            index + match$1[1] | 0
                          ];
                  } else {
                    return x;
                  }
                }))(Curry._1(f, str));
}

function manyCombinator(f) {
  var g = function (str) {
    return andMaybeCombinator(f, g, str);
  };
  return g;
}

function operatorMatcher(str) {
  var match = str.match(new RegExp("^[+-]"));
  if (match !== null) {
    return /* Some */[/* tuple */[
              /* :: */[
                /* Operator */Block.__(0, [Caml_array.caml_array_get(match, 0)]),
                /* [] */0
              ],
              Caml_array.caml_array_get(match, 0).length
            ]];
  } else {
    return /* None */0;
  }
}

function diceOrConstantMatcher(param) {
  return andCombinator(spaceMatcher, (function (param) {
                return orCombinator(diceExpMatcher, constantMatcher, param);
              }), param);
}

function spacedOperatorMatcher(param) {
  return andCombinator(spaceMatcher, operatorMatcher, param);
}

var partial_arg = manyCombinator((function (param) {
        return andCombinator(spacedOperatorMatcher, diceOrConstantMatcher, param);
      }));

function finalCombinator(param) {
  return andMaybeCombinator(diceOrConstantMatcher, partial_arg, param);
}

function parseRoll(exp) {
  return Utils.Option[/* bind */3]((function (param) {
                if (param[1] === exp.length) {
                  return /* Some */[$$Array.of_list(param[0])];
                } else {
                  return /* None */0;
                }
              }), finalCombinator(exp));
}

function stringifyRaw(f, tokens) {
  return tokens.map(Curry.__1(f)).join(" ");
}

function stringify(param) {
  return stringifyRaw((function (token) {
                switch (token.tag | 0) {
                  case 0 : 
                      return token[0];
                  case 1 : 
                      var max = token[2];
                      var min = token[1];
                      var count = token[0];
                      if (min === -1 && max === 1) {
                        return count.toString() + "dF";
                      } else if (min === 1) {
                        return count.toString() + ("d" + max.toString());
                      } else {
                        return count.toString() + ("r" + (min.toString() + (".." + max.toString())));
                      }
                  case 2 : 
                      return token[0].toString();
                  
                }
              }), param);
}

function roll(tokens, engine) {
  return tokens.map((function (token) {
                switch (token.tag | 0) {
                  case 1 : 
                      var max = token[2];
                      var min = token[1];
                      return Utils.arrayRange(token[0]).map((function () {
                                    console.log("Oh shit dawg", min, max);
                                    return Random.$$int(min, max)(engine);
                                  }));
                  case 0 : 
                  case 2 : 
                      return /* array */[];
                  
                }
              }));
}

function $$eval(tokens, rolls, state, onOperator, onConstant, onDice) {
  return Utils.arrayZip(tokens, rolls).reduce((function (state, param) {
                var token = param[0];
                switch (token.tag | 0) {
                  case 0 : 
                      return Curry._2(onOperator, token[0], state);
                  case 1 : 
                      return Curry._4(onDice, token[1], token[2], param[1], state);
                  case 2 : 
                      return Curry._2(onConstant, token[0], state);
                  
                }
              }), state);
}

function calculateTotal(tokens, rolls) {
  var operate = function (value, param) {
    var total = param[1];
    var adding = param[0];
    return /* tuple */[
            adding,
            adding ? total + value | 0 : total - value | 0
          ];
  };
  var sum = function (param) {
    return param.reduce((function (prim, prim$1) {
                  return prim + prim$1 | 0;
                }), 0);
  };
  return $$eval(tokens, rolls, /* tuple */[
                true,
                0
              ], (function (op) {
                  switch (op) {
                    case "+" : 
                        return (function (param) {
                            return /* tuple */[
                                    true,
                                    param[1]
                                  ];
                          });
                    case "-" : 
                        return (function (param) {
                            return /* tuple */[
                                    false,
                                    param[1]
                                  ];
                          });
                    default:
                      return (function (x) {
                          return x;
                        });
                  }
                }), operate, (function (_, _$1, rollArray) {
                  var partial_arg = sum(rollArray);
                  return (function (param) {
                      return operate(partial_arg, param);
                    });
                }))[1];
}

function emojifyFateDie(roll) {
  if (roll < 0) {
    return "⊟";
  } else if (roll > 0) {
    return "⊞";
  } else {
    return "⊡";
  }
}

function emojifyNumeralDie(roll) {
  if (roll > 10 || roll < 0) {
    return String(roll);
  } else {
    switch (roll) {
      case 0 : 
          return ":zero:";
      case 1 : 
          return ":one:";
      case 2 : 
          return ":two:";
      case 3 : 
          return ":three:";
      case 4 : 
          return ":four:";
      case 5 : 
          return ":five:";
      case 6 : 
          return ":six:";
      case 7 : 
          return ":seven:";
      case 8 : 
          return ":eight:";
      case 9 : 
          return ":nine:";
      case 10 : 
          return ":keycap_ten:";
      
    }
  }
}

function emojifyPercentageDie(roll) {
  if (roll !== 100) {
    return emojifyNumeralDie(roll / 10 | 0) + emojifyNumeralDie(roll % 10);
  } else {
    return ":100:";
  }
}

function emojifyPermillageDie(roll) {
  return emojifyNumeralDie(roll / 100 | 0) + (emojifyNumeralDie((roll / 10 | 0) % 10) + emojifyNumeralDie(roll % 10));
}

function emojifyD20Die(roll) {
  return String(roll);
}

function emojify(tokens, rolls) {
  return $$eval(tokens, rolls, "", (function (op, acc) {
                return acc + (" " + (op + " "));
              }), (function (value, acc) {
                return acc + String(value);
              }), (function (min, max, rolls, acc) {
                var array = rolls.map(min === -1 && max === 1 ? emojifyFateDie : (
                        min === 1 && max <= 10 ? emojifyNumeralDie : (
                            min === 1 && max === 20 ? emojifyD20Die : (
                                min === 1 && max === 100 ? emojifyPercentageDie : (
                                    min === 1 && max === 1000 ? emojifyPermillageDie : (function (prim) {
                                          return String(prim);
                                        })
                                  )
                              )
                          )
                      ));
                var inner = array.join(" + ");
                var match = array.length;
                return acc + (
                        match !== 1 ? "(" + (inner + ")") : inner
                      );
              }));
}

exports.getMatchLength = getMatchLength;
exports.diceExpMatcher = diceExpMatcher;
exports.constantMatcher = constantMatcher;
exports.spaceMatcher = spaceMatcher;
exports.orCombinator = orCombinator;
exports.andCombinator = andCombinator;
exports.andMaybeCombinator = andMaybeCombinator;
exports.manyCombinator = manyCombinator;
exports.operatorMatcher = operatorMatcher;
exports.diceOrConstantMatcher = diceOrConstantMatcher;
exports.spacedOperatorMatcher = spacedOperatorMatcher;
exports.finalCombinator = finalCombinator;
exports.parseRoll = parseRoll;
exports.stringifyRaw = stringifyRaw;
exports.stringify = stringify;
exports.roll = roll;
exports.$$eval = $$eval;
exports.calculateTotal = calculateTotal;
exports.emojifyFateDie = emojifyFateDie;
exports.emojifyNumeralDie = emojifyNumeralDie;
exports.emojifyPercentageDie = emojifyPercentageDie;
exports.emojifyPermillageDie = emojifyPermillageDie;
exports.emojifyD20Die = emojifyD20Die;
exports.emojify = emojify;
/* partial_arg Not a pure module */
