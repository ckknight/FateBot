// Generated by BUCKLESCRIPT VERSION 1.9.1, PLEASE EDIT WITH CARE
'use strict';

var Fs                      = require("fs");
var Block                   = require("bs-platform/lib/js/block.js");
var Curry                   = require("bs-platform/lib/js/curry.js");
var State                   = require("./state.js");
var Utils                   = require("./utils.js");
var Random                  = require("./random.js");
var Roller                  = require("./roller.js");
var Discord                 = require("./discord.js");
var Caml_obj                = require("bs-platform/lib/js/caml_obj.js");
var RandomJs                = require("random-js");
var Caml_array              = require("bs-platform/lib/js/caml_array.js");
var Discord$dotjs           = require("discord.js");
var Js_primitive            = require("bs-platform/lib/js/js_primitive.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var client = new Discord$dotjs.Client();

function role_of_user(user) {
  if (user.bot) {
    return /* Bot */3;
  } else {
    var match = user.username;
    switch (match) {
      case "Blaine66" : 
      case "FalconWiz" : 
          return /* Fucker */2;
      case "ckknight" : 
          return /* Admin */0;
      default:
        return /* Normie */1;
    }
  }
}

function handleAdminMessage(msg) {
  var author = msg.author;
  var match = msg.content.toLowerCase();
  if (match === "ping") {
    console.log("channel " + msg.channel.type);
    console.log("ping! pong. " + author.id);
    Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, "pong", msg);
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function handleNormieMessage(msg) {
  var author = msg.author;
  var match = msg.content.toLowerCase();
  if (match === "ping") {
    console.log("channel " + msg.channel.type);
    console.log("ping! pong. " + author.id);
    Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, "pong", msg);
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function handleFuckerMessage(msg) {
  var match = msg.content.toLowerCase();
  if (match === "ping") {
    Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, "kys, fucker", msg);
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function parseMatch(commandName, args) {
  switch (commandName) {
    case "8ball" : 
        return /* Some */[/* EightBall */3];
    case "get" : 
        return /* Some */[/* Get */2];
    case "help" : 
        return /* Some */[/* Help */1];
    case "ping" : 
        return /* Some */[/* Ping */0];
    case "roll" : 
        return Utils.Option[/* map */5]((function (x) {
                        return /* Roll */Block.__(0, [x]);
                      }))(Roller.parseRoll(args));
    case "set" : 
        return /* Some */[/* Set */Block.__(1, [args])];
    default:
      return /* None */0;
  }
}

function parseContent(prefix, content) {
  var match_ = content.match(new RegExp("^" + prefix + "(\\S+)\\s*(.*)"));
  if (match_ !== null) {
    return parseMatch(Caml_array.caml_array_get(match_, 1).toLowerCase(), Caml_array.caml_array_get(match_, 2));
  } else {
    return /* None */0;
  }
}

function parsePrefixedMessage(prefix, msg) {
  return parseContent(prefix, msg.content.trim());
}

function parseDirectMessage(param) {
  return parsePrefixedMessage("~?", param);
}

function parseChannelMessage(param) {
  return parsePrefixedMessage("~", param);
}

function parseMessage(msg) {
  var match = role_of_user(msg.author);
  if (match >= 3) {
    return /* None */0;
  } else {
    var match$1 = msg.channel.type;
    switch (match$1) {
      case "dm" : 
          return parseDirectMessage(msg);
      case "text" : 
          return parseChannelMessage(msg);
      default:
        return /* None */0;
    }
  }
}

var engine = RandomJs.engines.mt19937().autoSeed();

function logMessage(msg) {
  var author = msg.author;
  var channel = msg.channel;
  var match = Discord.Channel[/* classify */1](channel);
  var channelName;
  switch (match.tag | 0) {
    case 0 : 
        channelName = "DM";
        break;
    case 1 : 
        channelName = "Group DM";
        break;
    case 2 : 
        var textChannel = match[0];
        channelName = textChannel.guild.name + " #" + textChannel.name;
        break;
    case 3 : 
        channelName = "Voice";
        break;
    
  }
  var fullUsername = "@" + author.username + "#" + author.discriminator;
  var content = msg.content;
  console.log(channelName + ": " + fullUsername + "> " + content);
  return /* () */0;
}

var eightBallResults = Caml_obj.caml_obj_dup(/* array */[
      /* tuple */[
        /* Affirmative */0,
        "It is certain"
      ],
      /* tuple */[
        /* Affirmative */0,
        "It is decidedly so"
      ],
      /* tuple */[
        /* Affirmative */0,
        "Without a doubt"
      ],
      /* tuple */[
        /* Affirmative */0,
        "Yes definitely"
      ],
      /* tuple */[
        /* Affirmative */0,
        "You may rely on it"
      ],
      /* tuple */[
        /* Affirmative */0,
        "As I see it, yes"
      ],
      /* tuple */[
        /* Affirmative */0,
        "Most likely"
      ],
      /* tuple */[
        /* Affirmative */0,
        "Outlook good"
      ],
      /* tuple */[
        /* Affirmative */0,
        "Yes"
      ],
      /* tuple */[
        /* Affirmative */0,
        "Signs point to yes"
      ],
      /* tuple */[
        /* Noncommittal */1,
        "Reply hazy try again"
      ],
      /* tuple */[
        /* Noncommittal */1,
        "Ask again later"
      ],
      /* tuple */[
        /* Noncommittal */1,
        "Better not tell you now"
      ],
      /* tuple */[
        /* Noncommittal */1,
        "Cannot predict now"
      ],
      /* tuple */[
        /* Noncommittal */1,
        "Concentrate and ask again"
      ],
      /* tuple */[
        /* Negative */2,
        "Don't count on it"
      ],
      /* tuple */[
        /* Negative */2,
        "My reply is no"
      ],
      /* tuple */[
        /* Negative */2,
        "My sources say no"
      ],
      /* tuple */[
        /* Negative */2,
        "Outlook not so good"
      ],
      /* tuple */[
        /* Negative */2,
        "Very doubtful"
      ]
    ]);

function handleMessage(msg) {
  logMessage(msg);
  return Utils.Option[/* iter */7]((function (command) {
                if (typeof command === "number") {
                  switch (command) {
                    case 0 : 
                        console.log("ping from " + msg.author.username);
                        Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, "pong", msg);
                        return /* () */0;
                    case 1 : 
                        console.log("help from " + msg.author.username);
                        Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, "~roll d20 + 4d10 - 2d6 + 3dF + 5", msg);
                        return /* () */0;
                    case 2 : 
                        var state = State.UserState[/* get */0](msg.author);
                        Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, state[/* note */0], msg);
                        return /* () */0;
                    case 3 : 
                        var match = Utils.Option[/* orRaise */14]([
                              Caml_builtin_exceptions.failure,
                              "Expected a result"
                            ], Random.pick(/* None */0, /* None */0, eightBallResults, engine));
                        var tmp;
                        switch (match[0]) {
                          case 0 : 
                              tmp = ":+1:";
                              break;
                          case 1 : 
                              tmp = ":shrug:";
                              break;
                          case 2 : 
                              tmp = ":-1:";
                              break;
                          
                        }
                        Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, match[1] + " " + tmp, msg);
                        return /* () */0;
                    
                  }
                } else if (command.tag) {
                  var note = command[0];
                  State.UserState[/* update */2](msg.author, (function (state) {
                          return /* record */[
                                  /* note */note,
                                  /* rolls */state[/* rolls */1]
                                ];
                        }));
                  Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, "note = " + note, msg);
                  return /* () */0;
                } else {
                  var data = command[0];
                  State.UserState[/* update */2](msg.author, (function (state) {
                          return /* record */[
                                  /* note */state[/* note */0],
                                  /* rolls */state[/* rolls */1] + 1 | 0
                                ];
                        }));
                  console.log("roll from " + msg.author.username + " " + Roller.stringify(data));
                  var rolls = Roller.roll(data, engine);
                  Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* Some */[Discord.SplitOptions[/* make */0](/* None */0, /* None */0, /* None */0, /* None */0, /* () */0)], Roller.emojify(data, rolls) + " = " + String(Roller.calculateTotal(data, rolls)), msg);
                  return /* () */0;
                }
              }), parseMessage(msg));
}

client.on("ready", (function () {
        var eta = Utils.Option[/* orRaise */14]([
              Caml_builtin_exceptions.failure,
              "expected a user"
            ], Js_primitive.null_undefined_to_opt(client.user));
        var func = Discord.ClientUser[/* setPresence */1];
        Utils.promiseEnd(Utils.promiseMap((function (stuff) {
                      console.log(stuff);
                      return /* () */0;
                    }))(Curry._2((function (param, param$1) {
                          return Curry._3(func, param, param$1, /* Some */["~help"]);
                        })(/* None */0, /* None */0), /* None */0, eta)));
        console.log("Bot is ready!");
        return /* () */0;
      }));

client.on("message", handleMessage);

client.login(Fs.readFileSync("./token.txt", "utf8").trim());

var maxDiceCount = 100;

exports.maxDiceCount         = maxDiceCount;
exports.client               = client;
exports.role_of_user         = role_of_user;
exports.handleAdminMessage   = handleAdminMessage;
exports.handleNormieMessage  = handleNormieMessage;
exports.handleFuckerMessage  = handleFuckerMessage;
exports.parseMatch           = parseMatch;
exports.parseContent         = parseContent;
exports.parsePrefixedMessage = parsePrefixedMessage;
exports.parseDirectMessage   = parseDirectMessage;
exports.parseChannelMessage  = parseChannelMessage;
exports.parseMessage         = parseMessage;
exports.engine               = engine;
exports.logMessage           = logMessage;
exports.eightBallResults     = eightBallResults;
exports.handleMessage        = handleMessage;
/* client Not a pure module */
