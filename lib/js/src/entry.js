// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Giphy = require("./giphy.js");
var State = require("./state.js");
var Utils = require("./utils.js");
var Random = require("./random.js");
var Roller = require("./roller.js");
var Discord = require("./discord.js");
var GiphyApi = require("giphy-api");
var RandomJs = require("random-js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var DiscordJs = require("discord.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");
var Child_process = require("child_process");

var client = new DiscordJs.Client();

function role_of_user(user) {
  if (user.bot) {
    return /* Bot */3;
  } else {
    var match = user.username;
    switch (match) {
      case "Blaine66" : 
      case "FalconWiz" : 
          return /* Fucker */2;
      case "ckknight" : 
          return /* Admin */0;
      default:
        return /* Normie */1;
    }
  }
}

function handleAdminMessage(msg) {
  var author = msg.author;
  var match = msg.content.toLowerCase();
  if (match === "ping") {
    console.log("channel " + msg.channel.type);
    console.log("ping! pong. " + author.id);
    Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, "pong", msg);
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function handleNormieMessage(msg) {
  var author = msg.author;
  var match = msg.content.toLowerCase();
  if (match === "ping") {
    console.log("channel " + msg.channel.type);
    console.log("ping! pong. " + author.id);
    Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, "pong", msg);
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function handleFuckerMessage(msg) {
  var match = msg.content.toLowerCase();
  if (match === "ping") {
    Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, "kys, fucker", msg);
    return /* () */0;
  } else {
    return /* () */0;
  }
}

function parseMatch(commandName, args) {
  switch (commandName) {
    case "8ball" : 
        return /* Some */[/* EightBall */3];
    case "get" : 
        return /* Some */[/* Get */2];
    case "giphy" : 
        return /* Some */[/* Giphy */Block.__(2, [args])];
    case "help" : 
        return /* Some */[/* Help */1];
    case "ping" : 
        return /* Some */[/* Ping */0];
    case "poll" : 
        var match__ = args.match(new RegExp("^(\\d+)(?:-(\\d+))?\\s+"));
        if (match__ !== null) {
          if (Boolean(Caml_array.caml_array_get(match__, 2))) {
            return /* Some */[/* PollRange */Block.__(3, [
                        Utils.$$parseInt(1, Caml_array.caml_array_get(match__, 1)),
                        Utils.$$parseInt(10, Caml_array.caml_array_get(match__, 2))
                      ])];
          } else {
            return /* Some */[/* PollRange */Block.__(3, [
                        1,
                        Utils.$$parseInt(10, Caml_array.caml_array_get(match__, 1))
                      ])];
          }
        } else {
          return /* Some */[/* Poll */4];
        }
    case "roll" : 
        var __x = Roller.parseRoll(args);
        return Belt_Option.map(__x, (function (x) {
                      return /* Roll */Block.__(0, [x]);
                    }));
    case "set" : 
        return /* Some */[/* Set */Block.__(1, [args])];
    case "update" : 
        return /* Some */[/* Update */5];
    default:
      return /* None */0;
  }
}

function parseContent(prefix, content) {
  var match__ = content.match(new RegExp("^" + (prefix + "(\\S+)\\s*(.*)")));
  if (match__ !== null) {
    return parseMatch(Caml_array.caml_array_get(match__, 1).toLowerCase(), Caml_array.caml_array_get(match__, 2));
  } else {
    return /* None */0;
  }
}

function parsePrefixedMessage(prefix, msg) {
  return parseContent(prefix, msg.content.trim());
}

function parseDirectMessage(param) {
  return parsePrefixedMessage("~?", param);
}

function parseChannelMessage(param) {
  return parsePrefixedMessage("~", param);
}

function parseMessage(msg) {
  var match = role_of_user(msg.author);
  if (match >= 3) {
    return /* None */0;
  } else {
    var match$1 = msg.channel.type;
    switch (match$1) {
      case "dm" : 
          return parseDirectMessage(msg);
      case "text" : 
          return parseChannelMessage(msg);
      default:
        return /* None */0;
    }
  }
}

var engine = RandomJs.engines.mt19937().autoSeed();

function logMessage(msg) {
  var author = msg.author;
  var channel = msg.channel;
  var match = Discord.Channel[/* classify */1](channel);
  var channelName;
  switch (match.tag | 0) {
    case 0 : 
        channelName = "DM";
        break;
    case 1 : 
        channelName = "Group DM";
        break;
    case 2 : 
        var textChannel = match[0];
        channelName = textChannel.guild.name + (" #" + textChannel.name);
        break;
    case 3 : 
        channelName = "Voice";
        break;
    
  }
  var fullUsername = "@" + (author.username + ("#" + author.discriminator));
  var content = msg.content;
  console.log(channelName + (": " + (fullUsername + ("> " + content))));
  return /* () */0;
}

var eightBallResults = /* array */[
  /* tuple */[
    /* Affirmative */0,
    "It is certain"
  ],
  /* tuple */[
    /* Affirmative */0,
    "It is decidedly so"
  ],
  /* tuple */[
    /* Affirmative */0,
    "Without a doubt"
  ],
  /* tuple */[
    /* Affirmative */0,
    "Yes definitely"
  ],
  /* tuple */[
    /* Affirmative */0,
    "You may rely on it"
  ],
  /* tuple */[
    /* Affirmative */0,
    "As I see it, yes"
  ],
  /* tuple */[
    /* Affirmative */0,
    "Most likely"
  ],
  /* tuple */[
    /* Affirmative */0,
    "Outlook good"
  ],
  /* tuple */[
    /* Affirmative */0,
    "Yes"
  ],
  /* tuple */[
    /* Affirmative */0,
    "Signs point to yes"
  ],
  /* tuple */[
    /* Noncommittal */1,
    "Reply hazy try again"
  ],
  /* tuple */[
    /* Noncommittal */1,
    "Ask again later"
  ],
  /* tuple */[
    /* Noncommittal */1,
    "Better not tell you now"
  ],
  /* tuple */[
    /* Noncommittal */1,
    "Cannot predict now"
  ],
  /* tuple */[
    /* Noncommittal */1,
    "Concentrate and ask again"
  ],
  /* tuple */[
    /* Negative */2,
    "Don't count on it"
  ],
  /* tuple */[
    /* Negative */2,
    "My reply is no"
  ],
  /* tuple */[
    /* Negative */2,
    "My sources say no"
  ],
  /* tuple */[
    /* Negative */2,
    "Outlook not so good"
  ],
  /* tuple */[
    /* Negative */2,
    "Very doubtful"
  ]
];

function handleMessage(msg) {
  logMessage(msg);
  var match = parseMessage(msg);
  if (match) {
    var command = match[0];
    if (typeof command === "number") {
      switch (command) {
        case 0 : 
            console.log("ping from " + msg.author.username);
            Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, "pong!", msg);
            return /* () */0;
        case 1 : 
            console.log("help from " + msg.author.username);
            Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, "~roll d20 + 4d10 - 2d6 + 3dF + 5", msg);
            return /* () */0;
        case 2 : 
            var state = State.UserState[/* get */0](msg.author);
            Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, state[/* note */0], msg);
            return /* () */0;
        case 3 : 
            var match$1 = Belt_Option.getExn(Random.pick(/* None */0, /* None */0, eightBallResults, engine));
            var tmp;
            switch (match$1[0]) {
              case 0 : 
                  tmp = ":+1:";
                  break;
              case 1 : 
                  tmp = ":shrug:";
                  break;
              case 2 : 
                  tmp = ":-1:";
                  break;
              
            }
            Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, match$1[1] + (" " + tmp), msg);
            return /* () */0;
        case 4 : 
            msg.react("üëç").then((function () {
                      return msg.react("üëé");
                    })).then((function () {
                    return msg.react("ü§∑");
                  }));
            return /* () */0;
        case 5 : 
            var result = Child_process.execSync("git pull && yarn install --ignore-scripts", {
                  encoding: "utf8"
                });
            Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, result, msg);
            return /* () */0;
        
      }
    } else {
      switch (command.tag | 0) {
        case 0 : 
            var data = command[0];
            State.UserState[/* update */2](msg.author, (function (state) {
                    return /* record */[
                            /* note */state[/* note */0],
                            /* rolls */state[/* rolls */1] + 1 | 0
                          ];
                  }));
            console.log("roll from " + (msg.author.username + (" " + Roller.stringify(data))));
            var rolls = Roller.roll(data, engine);
            Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* Some */[Discord.SplitOptions[/* make */0](/* None */0, /* None */0, /* None */0, /* None */0, /* () */0)], Roller.emojify(data, rolls) + (" = " + String(Roller.calculateTotal(data, rolls))), msg);
            return /* () */0;
        case 1 : 
            var note = command[0];
            State.UserState[/* update */2](msg.author, (function (state) {
                    return /* record */[
                            /* note */note,
                            /* rolls */state[/* rolls */1]
                          ];
                  }));
            Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, "note = " + note, msg);
            return /* () */0;
        case 2 : 
            var client = GiphyApi();
            Giphy.random(command[0], client).then((function (url) {
                    return Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, url, msg);
                  }));
            return /* () */0;
        case 3 : 
            var finish = command[1];
            var start = command[0];
            var isValidRange = function (x) {
              if (x >= 1) {
                return x <= 10;
              } else {
                return false;
              }
            };
            var getEmojiStringForInt = function (x) {
              var switcher = x - 1 | 0;
              if (switcher > 9 || switcher < 0) {
                return Pervasives.failwith("Unexpected value");
              } else {
                switch (switcher) {
                  case 0 : 
                      return "1‚É£";
                  case 1 : 
                      return "2‚É£";
                  case 2 : 
                      return "3‚É£";
                  case 3 : 
                      return "4‚É£";
                  case 4 : 
                      return "5‚É£";
                  case 5 : 
                      return "6‚É£";
                  case 6 : 
                      return "7‚É£";
                  case 7 : 
                      return "8‚É£";
                  case 8 : 
                      return "9‚É£";
                  case 9 : 
                      return "üîü";
                  
                }
              }
            };
            if (isValidRange(start) && isValidRange(finish) && start <= finish) {
              var run = function (i) {
                if (i <= finish) {
                  return msg.react(getEmojiStringForInt(i)).then((function () {
                                return run(i + 1 | 0);
                              }));
                } else {
                  return Promise.resolve(/* () */0);
                }
              };
              run(start);
              return /* () */0;
            } else {
              return 0;
            }
        
      }
    }
  } else {
    return /* () */0;
  }
}

client.on("error", (function (exn) {
        var match = Utils.exnCode(exn);
        if (match) {
          if (match[0] === "ECONNRESET") {
            console.log("Connection reset");
            return /* () */0;
          } else {
            console.log(exn);
            return /* () */0;
          }
        } else {
          console.log(exn);
          return /* () */0;
        }
      }));

client.on("ready", (function () {
        var eta = Belt_Option.getExn(Js_primitive.null_undefined_to_opt(client.user));
        var func = Discord.ClientUser[/* setPresence */1];
        Utils.promiseEnd(Utils.promiseMap((function (stuff) {
                      console.log(stuff);
                      return /* () */0;
                    }))(Curry._2((function (param, param$1) {
                          return Curry._3(func, param, param$1, /* Some */["~help"]);
                        })(/* None */0, /* None */0), /* None */0, eta)));
        console.log("Bot is ready!");
        return /* () */0;
      }));

client.on("message", handleMessage);

var token = Fs.readFileSync("./token.txt", "utf8").trim();

client.login(token);

var maxDiceCount = 100;

exports.maxDiceCount = maxDiceCount;
exports.client = client;
exports.role_of_user = role_of_user;
exports.handleAdminMessage = handleAdminMessage;
exports.handleNormieMessage = handleNormieMessage;
exports.handleFuckerMessage = handleFuckerMessage;
exports.parseMatch = parseMatch;
exports.parseContent = parseContent;
exports.parsePrefixedMessage = parsePrefixedMessage;
exports.parseDirectMessage = parseDirectMessage;
exports.parseChannelMessage = parseChannelMessage;
exports.parseMessage = parseMessage;
exports.engine = engine;
exports.logMessage = logMessage;
exports.eightBallResults = eightBallResults;
exports.handleMessage = handleMessage;
exports.token = token;
/* client Not a pure module */
