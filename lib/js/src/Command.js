// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var Tak = require("./Tak.js");
var Block = require("bs-platform/lib/js/block.js");
var Giphy = require("./Giphy.js");
var State = require("./State.js");
var Utils = require("./Utils.js");
var Roller = require("./Roller.js");
var Discord = require("./Discord.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var EightBall = require("./EightBall.js");
var GiphyApi = require("giphy-api");
var RandomJs = require("random-js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");
var Child_process = require("child_process");

function parseTakPosition(columnString, rowString) {
  var column = Utils.$$parseInt(0, columnString) - 1 | 0;
  var row = rowString.toUpperCase().charCodeAt(0) - "A".charCodeAt(0) | 0;
  return Tak.position(column, row);
}

function parsePrefixedMessage(prefix, client, msg) {
  var prefix$1 = prefix;
  var client$1 = client;
  var content = msg.content.trim();
  var __x = content.match(new RegExp("^(?:<@" + (Belt_Option.getExn(Js_primitive.null_undefined_to_opt(client$1.user)).id + (">[,:]?\\s*|" + (prefix$1 + ")(\\S+)\\s*(.*)")))));
  return Belt_Option.flatMap(__x === null ? /* None */0 : [__x], (function (match__) {
                var commandName = Caml_array.caml_array_get(match__, 1).toLowerCase();
                var args = Caml_array.caml_array_get(match__, 2);
                switch (commandName) {
                  case "8ball" : 
                      return /* Some */[/* EightBall */3];
                  case "get" : 
                      return /* Some */[/* Get */2];
                  case "giphy" : 
                      return /* Some */[/* Giphy */Block.__(2, [args])];
                  case "help" : 
                      return /* Some */[/* Help */1];
                  case "ping" : 
                      return /* Some */[/* Ping */0];
                  case "poll" : 
                      var match__$1 = args.match(new RegExp("^(\\d+)(?:-(\\d+))?\\b"));
                      if (match__$1 !== null) {
                        if (Boolean(Caml_array.caml_array_get(match__$1, 2))) {
                          return /* Some */[/* PollRange */Block.__(3, [
                                      Utils.$$parseInt(1, Caml_array.caml_array_get(match__$1, 1)),
                                      Utils.$$parseInt(10, Caml_array.caml_array_get(match__$1, 2))
                                    ])];
                        } else {
                          return /* Some */[/* PollRange */Block.__(3, [
                                      1,
                                      Utils.$$parseInt(10, Caml_array.caml_array_get(match__$1, 1))
                                    ])];
                        }
                      } else {
                        return /* Some */[/* Poll */4];
                      }
                  case "roll" : 
                      var __x = Roller.parseRoll(args);
                      return Belt_Option.map(__x, (function (x) {
                                    return /* Roll */Block.__(0, [x]);
                                  }));
                  case "set" : 
                      return /* Some */[/* Set */Block.__(1, [args])];
                  case "tak" : 
                      var args$1 = args;
                      var __x$1 = args$1.match(new RegExp("^(place|move)\\s+(.*)$", "i"));
                      return Belt_Option.flatMapU(__x$1 === null ? /* None */0 : [__x$1], (function (match__) {
                                    var match = Caml_array.caml_array_get(match__, 1);
                                    switch (match) {
                                      case "move" : 
                                          var args = Caml_array.caml_array_get(match__, 2);
                                          var __x = args.match(new RegExp("^(\\d)([A-Z]) ([NESW])((?:\\s+\\d+)+)$", "i"));
                                          return Belt_Option.mapU(__x === null ? /* None */0 : [__x], (function (match__) {
                                                        var position = parseTakPosition(Caml_array.caml_array_get(match__, 1), Caml_array.caml_array_get(match__, 2));
                                                        var match = Caml_array.caml_array_get(match__, 3).toUpperCase();
                                                        var direction;
                                                        switch (match) {
                                                          case "E" : 
                                                              direction = /* East */1;
                                                              break;
                                                          case "N" : 
                                                              direction = /* North */0;
                                                              break;
                                                          case "S" : 
                                                              direction = /* South */2;
                                                              break;
                                                          case "W" : 
                                                              direction = /* West */3;
                                                              break;
                                                          default:
                                                            direction = Pervasives.failwith("Unknown direction " + Caml_array.caml_array_get(match__, 3));
                                                        }
                                                        var __x = Caml_array.caml_array_get(match__, 4).trim().split(new RegExp("\\s+"));
                                                        var leftStones = Tak.leftStones(Belt_List.fromArray(Belt_Array.mapU(__x, (function (value) {
                                                                        return Utils.$$parseInt(0, value);
                                                                      }))));
                                                        return /* TakPlay */Block.__(4, [/* Move */Block.__(1, [
                                                                      position,
                                                                      direction,
                                                                      leftStones
                                                                    ])]);
                                                      }));
                                      case "place" : 
                                          var args$1 = Caml_array.caml_array_get(match__, 2);
                                          var __x$1 = args$1.match(new RegExp("^(c|f|s)?\\s*(\\d)([A-Z])$", "i"));
                                          return Belt_Option.mapU(__x$1 === null ? /* None */0 : [__x$1], (function (match__) {
                                                        var match = Boolean(Caml_array.caml_array_get(match__, 1));
                                                        var match$1 = match ? Caml_array.caml_array_get(match__, 1).toUpperCase() : "";
                                                        var stoneType;
                                                        switch (match$1) {
                                                          case "C" : 
                                                              stoneType = /* Capstone */2;
                                                              break;
                                                          case "S" : 
                                                              stoneType = /* StandingStone */1;
                                                              break;
                                                          default:
                                                            stoneType = /* FlatStone */0;
                                                        }
                                                        var position = parseTakPosition(Caml_array.caml_array_get(match__, 2), Caml_array.caml_array_get(match__, 3));
                                                        return /* TakPlay */Block.__(4, [/* Place */Block.__(0, [
                                                                      stoneType,
                                                                      position
                                                                    ])]);
                                                      }));
                                      default:
                                        return /* None */0;
                                    }
                                  }));
                  case "update" : 
                      return /* Some */[/* Update */5];
                  default:
                    return /* None */0;
                }
              }));
}

function parseMessage(client, msg) {
  var match = msg.channel.type;
  switch (match) {
    case "dm" : 
        return parsePrefixedMessage("~?", client, msg);
    case "text" : 
        return parsePrefixedMessage("~", client, msg);
    default:
      return /* None */0;
  }
}

var engine = RandomJs.engines.mt19937().autoSeed();

var takGame = [Tak.create(5)];

function showTak(board) {
  var size = Tak.boardSize(board);
  var match = Tak.whoseTurn(board);
  var __x = Belt_Array.range(0, size - 1 | 0);
  return (
          match ? (
              match[0] ? "Black's turn" : "White's turn"
            ) : "Nobody's turn"
        ) + ("\n" + Belt_Array.mapU(__x, (function (row) {
                    var __x = Belt_Array.range(0, size - 1 | 0);
                    return Belt_Array.mapU(__x, (function (column) {
                                    var pieces = Tak.pieces(Tak.position(column, row), board);
                                    if (pieces) {
                                      var match = pieces[0];
                                      var stoneType = match[1];
                                      if (match[0]) {
                                        switch (stoneType) {
                                          case 0 : 
                                              return "◾";
                                          case 1 : 
                                              return "●";
                                          case 2 : 
                                              return "🌚";
                                          
                                        }
                                      } else {
                                        switch (stoneType) {
                                          case 0 : 
                                              return "◽";
                                          case 1 : 
                                              return "○";
                                          case 2 : 
                                              return "🌝";
                                          
                                        }
                                      }
                                    } else {
                                      return "🕳️";
                                    }
                                  })).join("");
                  })).join("\n"));
}

function handleMessage(msg, command) {
  if (typeof command === "number") {
    switch (command) {
      case 0 : 
          var msg$1 = msg;
          console.log("ping from " + msg$1.author.username);
          Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, "pong!", msg$1);
          return /* () */0;
      case 1 : 
          var msg$2 = msg;
          Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* array */[
                  "~roll d20 + 4d10 - 2d6 + 3dF + 5",
                  "~8ball",
                  "~giphy cats",
                  "~poll [[min-]max] [topic]"
                ].join("\n"), msg$2);
          return /* () */0;
      case 2 : 
          var msg$3 = msg;
          var state = State.UserState[/* get */0](msg$3.author);
          Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, state[/* note */0], msg$3);
          return /* () */0;
      case 3 : 
          return EightBall.handle(engine, msg);
      case 4 : 
          var msg$4 = msg;
          msg$4.react("👍").then((function () {
                    return msg$4.react("👎");
                  })).then((function () {
                  return msg$4.react("🤷");
                }));
          return /* () */0;
      case 5 : 
          var msg$5 = msg;
          var result = Child_process.execSync("git pull && yarn install --ignore-scripts", {
                encoding: "utf8"
              });
          Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, result, msg$5);
          return /* () */0;
      
    }
  } else {
    switch (command.tag | 0) {
      case 0 : 
          var data = command[0];
          var msg$6 = msg;
          State.UserState[/* update */2](msg$6.author, (function (state) {
                  return /* record */[
                          /* note */state[/* note */0],
                          /* rolls */state[/* rolls */1] + 1 | 0
                        ];
                }));
          console.log("roll from " + (msg$6.author.username + (" " + Roller.stringify(data))));
          var rolls = Roller.roll(data, engine);
          Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* Some */[Discord.SplitOptions[/* make */0](/* None */0, /* None */0, /* None */0, /* None */0, /* () */0)], Roller.emojify(data, rolls) + (" = " + String(Roller.calculateTotal(data, rolls))), msg$6);
          return /* () */0;
      case 1 : 
          var note = command[0];
          var msg$7 = msg;
          State.UserState[/* update */2](msg$7.author, (function (state) {
                  return /* record */[
                          /* note */note,
                          /* rolls */state[/* rolls */1]
                        ];
                }));
          Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, "note = " + note, msg$7);
          return /* () */0;
      case 2 : 
          var search = command[0];
          var msg$8 = msg;
          var client = GiphyApi();
          Giphy.random(search, client).then((function (url) {
                  return Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, url, msg$8);
                }));
          return /* () */0;
      case 3 : 
          var start = command[0];
          var finish = command[1];
          var msg$9 = msg;
          var isValidRange = function (x) {
            if (x >= 1) {
              return x <= 10;
            } else {
              return false;
            }
          };
          var getEmojiStringForInt = function (x) {
            var switcher = x - 1 | 0;
            if (switcher > 9 || switcher < 0) {
              return Pervasives.failwith("Unexpected value");
            } else {
              switch (switcher) {
                case 0 : 
                    return "1⃣";
                case 1 : 
                    return "2⃣";
                case 2 : 
                    return "3⃣";
                case 3 : 
                    return "4⃣";
                case 4 : 
                    return "5⃣";
                case 5 : 
                    return "6⃣";
                case 6 : 
                    return "7⃣";
                case 7 : 
                    return "8⃣";
                case 8 : 
                    return "9⃣";
                case 9 : 
                    return "🔟";
                
              }
            }
          };
          if (isValidRange(start) && isValidRange(finish) && start <= finish) {
            var run = function (i) {
              if (i <= finish) {
                return msg$9.react(getEmojiStringForInt(i)).then((function () {
                              return run(i + 1 | 0);
                            }));
              } else {
                return Promise.resolve(/* () */0);
              }
            };
            run(start);
            return /* () */0;
          } else {
            return 0;
          }
      case 4 : 
          var action = command[0];
          var msg$10 = msg;
          var match = Tak.dispatch(action, takGame[0]);
          if (match) {
            takGame[0] = match[0];
            Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, showTak(takGame[0]), msg$10);
          } else {
            Discord.Message[/* reply */0](/* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, "Invalid action", msg$10);
          }
          return /* () */0;
      
    }
  }
}

exports.parseMessage = parseMessage;
exports.handleMessage = handleMessage;
/* engine Not a pure module */
