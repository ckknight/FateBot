// Generated by BUCKLESCRIPT VERSION 3.1.1, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Utils = require("./Utils.js");
var Random = require("./Random.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");

function getMatchLength(match__) {
  return Caml_array.caml_array_get(match__, 0).length;
}

function diceExpMatcher(str) {
  var __x = str.match(new RegExp("^([1-9][0-9]*)?(?:d|D)((?:([1-9][0-9]*)(?:\\.\\.([1-9][0-9]*))?)|\\%|f|F)"));
  return Belt_Option.map(__x === null ? /* None */0 : [__x], (function (match__) {
                var diceCount = Utils.$$parseInt(1, Caml_array.caml_array_get(match__, 1));
                var match = Caml_array.caml_array_get(match__, 2).toLowerCase();
                var dice;
                switch (match) {
                  case "%" : 
                      dice = /* Dice */Block.__(1, [
                          diceCount,
                          1,
                          100
                        ]);
                      break;
                  case "f" : 
                      dice = /* Dice */Block.__(1, [
                          diceCount,
                          -1,
                          1
                        ]);
                      break;
                  default:
                    dice = Boolean(Caml_array.caml_array_get(match__, 4)) ? /* Dice */Block.__(1, [
                          diceCount,
                          Utils.$$parseInt(1, Caml_array.caml_array_get(match__, 3)),
                          Utils.$$parseInt(1, Caml_array.caml_array_get(match__, 4))
                        ]) : /* Dice */Block.__(1, [
                          diceCount,
                          1,
                          Utils.$$parseInt(6, Caml_array.caml_array_get(match__, 3))
                        ]);
                }
                return /* tuple */[
                        /* :: */[
                          dice,
                          /* [] */0
                        ],
                        Caml_array.caml_array_get(match__, 0).length
                      ];
              }));
}

function constantMatcher(str) {
  var __x = str.match(new RegExp("^([1-9][0-9]*)"));
  return Belt_Option.map(__x === null ? /* None */0 : [__x], (function (match__) {
                var value = Utils.$$parseInt(0, Caml_array.caml_array_get(match__, 1));
                return /* tuple */[
                        /* :: */[
                          /* Constant */Block.__(2, [value]),
                          /* [] */0
                        ],
                        Caml_array.caml_array_get(match__, 0).length
                      ];
              }));
}

function spaceMatcher(str) {
  var __x = str.match(new RegExp("^\\s*"));
  return Belt_Option.map(__x === null ? /* None */0 : [__x], (function (match__) {
                return /* tuple */[
                        /* [] */0,
                        Caml_array.caml_array_get(match__, 0).length
                      ];
              }));
}

function orCombinator(f, g, str) {
  var t = Curry._1(f, str);
  if (t) {
    return t;
  } else {
    return Curry._1(g, str);
  }
}

function andCombinator(f, g, str) {
  var __x = Curry._1(f, str);
  return Belt_Option.flatMap(__x, (function (param) {
                var index = param[1];
                var tokens = param[0];
                var __x = Curry._1(g, str.substring(index));
                return Belt_Option.map(__x, (function (param) {
                              return /* tuple */[
                                      Pervasives.$at(tokens, param[0]),
                                      index + param[1] | 0
                                    ];
                            }));
              }));
}

function andMaybeCombinator(f, g, str) {
  var __x = Curry._1(f, str);
  return Belt_Option.map(__x, (function (x) {
                var index = x[1];
                var match = Curry._1(g, str.substring(index));
                if (match) {
                  var match$1 = match[0];
                  return /* tuple */[
                          Pervasives.$at(x[0], match$1[0]),
                          index + match$1[1] | 0
                        ];
                } else {
                  return x;
                }
              }));
}

function manyCombinator(f) {
  var g = function (str) {
    return andMaybeCombinator(f, g, str);
  };
  return g;
}

function operatorMatcher(str) {
  var match = str.match(new RegExp("^[+-]"));
  if (match !== null) {
    return /* Some */[/* tuple */[
              /* :: */[
                /* Operator */Block.__(0, [Caml_array.caml_array_get(match, 0)]),
                /* [] */0
              ],
              Caml_array.caml_array_get(match, 0).length
            ]];
  } else {
    return /* None */0;
  }
}

function diceOrConstantMatcher(param) {
  return andCombinator(spaceMatcher, (function (param) {
                return orCombinator(diceExpMatcher, constantMatcher, param);
              }), param);
}

function spacedOperatorMatcher(param) {
  return andCombinator(spaceMatcher, operatorMatcher, param);
}

var partial_arg = manyCombinator((function (param) {
        return andCombinator(spacedOperatorMatcher, diceOrConstantMatcher, param);
      }));

function finalCombinator(param) {
  return andMaybeCombinator(diceOrConstantMatcher, partial_arg, param);
}

function parseRoll(exp) {
  var __x = finalCombinator(exp);
  return Belt_Option.flatMap(__x, (function (param) {
                if (param[1] === exp.length) {
                  return /* Some */[$$Array.of_list(param[0])];
                } else {
                  return /* None */0;
                }
              }));
}

function stringifyRaw(f, tokens) {
  return Belt_Array.map(tokens, f).join(" ");
}

function stringify(param) {
  return stringifyRaw((function (token) {
                switch (token.tag | 0) {
                  case 0 : 
                      return token[0];
                  case 1 : 
                      var max = token[2];
                      var min = token[1];
                      var count = token[0];
                      if (min === -1 && max === 1) {
                        return count.toString() + "dF";
                      } else if (min === 1) {
                        return count.toString() + ("d" + max.toString());
                      } else {
                        return count.toString() + ("r" + (min.toString() + (".." + max.toString())));
                      }
                  case 2 : 
                      return token[0].toString();
                  
                }
              }), param);
}

function roll(tokens, engine) {
  return Belt_Array.map(tokens, (function (token) {
                switch (token.tag | 0) {
                  case 1 : 
                      var max = token[2];
                      var min = token[1];
                      var __x = Belt_Array.range(1, token[0]);
                      return Belt_Array.map(__x, (function () {
                                    return Random.$$int(min, max)(engine);
                                  }));
                  case 0 : 
                  case 2 : 
                      return /* array */[];
                  
                }
              }));
}

function $$eval(tokens, rolls, state, onOperator, onConstant, onDice) {
  var __x = Belt_Array.zip(tokens, rolls);
  return Belt_Array.reduce(__x, state, (function (state, param) {
                var token = param[0];
                switch (token.tag | 0) {
                  case 0 : 
                      return Curry._2(onOperator, token[0], state);
                  case 1 : 
                      return Curry._4(onDice, token[1], token[2], param[1], state);
                  case 2 : 
                      return Curry._2(onConstant, token[0], state);
                  
                }
              }));
}

function calculateTotal(tokens, rolls) {
  var operate = function (value, param) {
    var total = param[1];
    var adding = param[0];
    return /* tuple */[
            adding,
            adding ? total + value | 0 : total - value | 0
          ];
  };
  var sum = function (__x) {
    return Belt_Array.reduce(__x, 0, (function (prim, prim$1) {
                  return prim + prim$1 | 0;
                }));
  };
  return $$eval(tokens, rolls, /* tuple */[
                true,
                0
              ], (function (op) {
                  switch (op) {
                    case "+" : 
                        return (function (param) {
                            return /* tuple */[
                                    true,
                                    param[1]
                                  ];
                          });
                    case "-" : 
                        return (function (param) {
                            return /* tuple */[
                                    false,
                                    param[1]
                                  ];
                          });
                    default:
                      return (function (x) {
                          return x;
                        });
                  }
                }), operate, (function (_, _$1, rollArray) {
                  var partial_arg = sum(rollArray);
                  return (function (param) {
                      return operate(partial_arg, param);
                    });
                }))[1];
}

function emojifyFateDie(roll) {
  if (roll < 0) {
    return "⊟";
  } else if (roll > 0) {
    return "⊞";
  } else {
    return "⊡";
  }
}

function emojifyNumeralDie(roll) {
  if (roll > 10 || roll < 0) {
    return String(roll);
  } else {
    switch (roll) {
      case 0 : 
          return ":zero:";
      case 1 : 
          return ":one:";
      case 2 : 
          return ":two:";
      case 3 : 
          return ":three:";
      case 4 : 
          return ":four:";
      case 5 : 
          return ":five:";
      case 6 : 
          return ":six:";
      case 7 : 
          return ":seven:";
      case 8 : 
          return ":eight:";
      case 9 : 
          return ":nine:";
      case 10 : 
          return ":keycap_ten:";
      
    }
  }
}

function emojifyPercentageDie(roll) {
  if (roll !== 100) {
    return emojifyNumeralDie(roll / 10 | 0) + emojifyNumeralDie(roll % 10);
  } else {
    return ":100:";
  }
}

function emojifyPermillageDie(roll) {
  return emojifyNumeralDie(roll / 100 | 0) + (emojifyNumeralDie((roll / 10 | 0) % 10) + emojifyNumeralDie(roll % 10));
}

function emojifyD20Die(roll) {
  return String(roll);
}

function emojify(tokens, rolls) {
  return $$eval(tokens, rolls, "", (function (op, acc) {
                return acc + (" " + (op + " "));
              }), (function (value, acc) {
                return acc + String(value);
              }), (function (min, max, rolls, acc) {
                var array = Belt_Array.map(rolls, min === -1 && max === 1 ? emojifyFateDie : (
                        min === 1 && max <= 10 ? emojifyNumeralDie : (
                            min === 1 && max === 20 ? emojifyD20Die : (
                                min === 1 && max === 100 ? emojifyPercentageDie : (
                                    min === 1 && max === 1000 ? emojifyPermillageDie : (function (prim) {
                                          return String(prim);
                                        })
                                  )
                              )
                          )
                      ));
                var inner = array.join(" + ");
                var match = array.length;
                return acc + (
                        match !== 1 ? "(" + (inner + ")") : inner
                      );
              }));
}

exports.getMatchLength = getMatchLength;
exports.diceExpMatcher = diceExpMatcher;
exports.constantMatcher = constantMatcher;
exports.spaceMatcher = spaceMatcher;
exports.orCombinator = orCombinator;
exports.andCombinator = andCombinator;
exports.andMaybeCombinator = andMaybeCombinator;
exports.manyCombinator = manyCombinator;
exports.operatorMatcher = operatorMatcher;
exports.diceOrConstantMatcher = diceOrConstantMatcher;
exports.spacedOperatorMatcher = spacedOperatorMatcher;
exports.finalCombinator = finalCombinator;
exports.parseRoll = parseRoll;
exports.stringifyRaw = stringifyRaw;
exports.stringify = stringify;
exports.roll = roll;
exports.$$eval = $$eval;
exports.calculateTotal = calculateTotal;
exports.emojifyFateDie = emojifyFateDie;
exports.emojifyNumeralDie = emojifyNumeralDie;
exports.emojifyPercentageDie = emojifyPercentageDie;
exports.emojifyPermillageDie = emojifyPermillageDie;
exports.emojifyD20Die = emojifyD20Die;
exports.emojify = emojify;
/* partial_arg Not a pure module */
